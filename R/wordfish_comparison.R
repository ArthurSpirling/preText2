#' @title Wordfish Comparison.
#' @description Calculates Wordfish scores for a list of dfm objects with
#' temporal filtering.
#'
#' @param dfm_list A list of quanteda dfm objects generated by the
#' \code{factorial_preprocessing()} function.
#' @param years A numeric vector giving the year for each document.
#' @param anchors A numeric vector of length two used to anchor the Wordfish
#' estimates. Defaults to c(1, 24).
#' @param proportion_threshold Proportion of years a term must be included in
#' to be included. Defaults to 1.
#' @param document_inidices An optional vector of row indices for subsetting.
#' @return A result list with score_list and max_min matrices.
#' @examples
#' \dontrun{
#' # See package vignette for full example.
#' }
#' @export
wordfish_comparison <- function(dfm_list,
                                 years,
                                 anchors = c(1, 24),
                                 proportion_threshold = 1,
                                 document_inidices = NULL) {

    if (!requireNamespace("quanteda.textmodels", quietly = TRUE)) {
        stop("The 'quanteda.textmodels' package is required for wordfish_comparison(). ",
             "Install it with: install.packages('quanteda.textmodels')")
    }

    dfm_object_list <- dfm_list
    num_dfms <- length(dfm_object_list)

    score_list <- vector(mode = "list", length = num_dfms)
    max_min <- matrix(0, nrow = num_dfms, ncol = 2)

    for (i in 1:num_dfms) {
        cat("Currently working on dfm", i, "of", num_dfms, "\n")
        ptm <- proc.time()

        cur_dfm <- dfm_object_list[[i]]

        if (!is.null(document_inidices)) {
            cur_dfm <- cur_dfm[document_inidices, ]
            # Remove zero-count features
            cur_dfm <- quanteda::dfm_trim(cur_dfm, min_termfreq = 1)
            reduced_years <- years[document_inidices]
        } else {
            reduced_years <- years
        }

        # Apply temporal filter using proportion threshold
        if (proportion_threshold < 1) {
            unique_years <- unique(reduced_years)
            n_years <- length(unique_years)
            min_years <- ceiling(proportion_threshold * n_years)

            # Count how many years each term appears in
            year_counts <- rep(0, quanteda::nfeat(cur_dfm))
            for (yr in unique_years) {
                yr_docs <- which(reduced_years == yr)
                yr_dfm <- cur_dfm[yr_docs, ]
                year_counts <- year_counts + (Matrix::colSums(yr_dfm) > 0)
            }

            keep_terms <- which(year_counts >= min_years)
            if (length(keep_terms) > 0) {
                cur_dfm <- cur_dfm[, keep_terms]
            }
        }

        # Fit wordfish
        wf <- quanteda.textmodels::textmodel_wordfish(cur_dfm,
                                                       dir = anchors)

        score_list[[i]] <- wf$theta
        max_min[i, 1] <- max(wf$theta)
        max_min[i, 2] <- min(wf$theta)

        t <- proc.time() - ptm
        cat("Completed in", t[3], "seconds.\n")
    }

    return(list(score_list = score_list,
                max_min = max_min))
}


#' @title Plot of Wordfish rankings of documents
#' @description Creates a plot showing how document rankings vary across
#' preprocessing specifications using Wordfish.
#'
#' @param wordfish_results Results from \code{wordfish_comparison()}.
#' @param labels Optional document labels.
#' @return A plot.
#' @examples
#' \dontrun{
#' # See package vignette.
#' }
#' @export
wordfish_rank_plot <- function(wordfish_results, labels = NULL) {

    score_list <- wordfish_results$score_list
    num_specs <- length(score_list)

    if (is.null(labels)) {
        labels <- paste0("Doc_", seq_along(score_list[[1]]))
    }

    # Get rankings for each specification
    ndocs <- length(score_list[[1]])
    rank_matrix <- matrix(0, nrow = num_specs, ncol = ndocs)
    for (i in 1:num_specs) {
        rank_matrix[i, ] <- rank(score_list[[i]])
    }

    # Plot average rank with range
    avg_ranks <- colMeans(rank_matrix)
    min_ranks <- apply(rank_matrix, 2, min)
    max_ranks <- apply(rank_matrix, 2, max)

    ord <- order(avg_ranks)

    graphics::plot(avg_ranks[ord], 1:ndocs,
                   xlim = c(0, ndocs + 1),
                   pch = 19, cex = 0.5,
                   xlab = "Wordfish Rank",
                   ylab = "",
                   yaxt = "n",
                   main = "Wordfish Rankings Across Preprocessing")
    graphics::segments(min_ranks[ord], 1:ndocs,
                       max_ranks[ord], 1:ndocs,
                       col = grDevices::gray(0.5))
    graphics::axis(2, at = 1:ndocs, labels = labels[ord],
                   las = 1, cex.axis = 0.6)
}
